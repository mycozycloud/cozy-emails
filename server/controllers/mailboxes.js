// Generated by CoffeeScript 1.6.3
var MailFolder, MailSent, Mailbox, async, mimelib;

mimelib = require("mimelib");

async = require("async");

Mailbox = require('../models/mailbox');

MailFolder = require('../models/mailfolder');

MailSent = require('../models/mailsent');

module.exports = {
  getMailbox: function(req, res, next, id) {
    var _this = this;
    return Mailbox.find(id, function(err, box) {
      if (err) {
        return next(err);
      } else if (!box) {
        return res.send({
          error: 'not found'
        }, 404);
      } else {
        req.box = box;
        return next();
      }
    });
  },
  index: function(req, res, next) {
    var mailboxes;
    mailboxes = [];
    return Mailbox.all(function(err, boxes) {
      if (err) {
        return next(err);
      } else {
        if (!boxes) {
          boxes = [];
        }
        return res.send(boxes);
      }
    });
  },
  create: function(req, res, next) {
    return Mailbox.findByEmail(req.body.login, function(err, box) {
      if (err) {
        console.log(err);
        return res.send({
          error: err
        }, 500);
      } else if (box != null) {
        if (box != null) {
          return res.send({
            error: "Box already exists"
          }, 400);
        }
      } else {
        return Mailbox.create(req.body, function(err, mailbox) {
          if (err) {
            console.log(err);
            return res.send({
              error: err
            }, 500);
          } else {
            res.send(mailbox);
            return mailbox.fullImport();
          }
        });
      }
    });
  },
  show: function(req, res, next) {
    return res.send(req.box);
  },
  update: function(req, res, next) {
    var body,
      _this = this;
    body = req.body;
    return req.box.updateAttributes(body, function(err) {
      var _ref;
      if (err) {
        return next(err);
      } else {
        res.send({
          success: true
        });
        if ((_this.box != null) && ((_ref = !_this.box.status) === "imported" || _ref === "importing")) {
          return req.box.reset(function() {
            return req.box.fullImport();
          });
        }
      }
    });
  },
  destroy: function(req, res, next) {
    return req.box.boxDeleting(function(err) {
      if (err) {
        return next(err);
      } else {
        return req.box.stopImport(function(err) {
          if (err) {
            return next(err);
          } else {
            return req.box.remove(function(err) {
              if (err) {
                return next(err);
              } else {
                return res.send({
                  sucess: true
                }, 204);
              }
            });
          }
        });
      }
    });
  },
  sendMail: function(req, res, next) {
    var body,
      _this = this;
    body = req.body;
    body.createdAt = new Date().valueOf();
    return req.box.res.sendMail(body, function(err) {
      if (err) {
        return next(err);
      } else {
        body.to = JSON.stringify(mimelib.parseAddresses(data.to));
        body.bcc = JSON.stringify(mimelib.parseAddresses(data.bcc));
        body.cc = JSON.stringify(mimelib.parseAddresses(data.cc));
        body.mailbox = req.box.id;
        body.sentAt = new Date().valueOf();
        body.from = req.box.smtpSendAs;
        return MailSent.create(body, function(err) {
          if (err) {
            return next(err);
          } else {
            return res.send({
              sucess: true
            }, 204);
          }
        });
      }
    });
  },
  fetchNew: function(req, res, next) {
    return Mailbox.all(function(err, boxes) {
      if (err) {
        return next(err);
      } else {
        if (!boxes) {
          boxes = [];
        }
        return async.eachSeries(boxes, function(box, callback) {
          if (box.status !== "imported") {
            return callback();
          } else {
            return box.getMailGetter(function(err, getter) {
              if (err) {
                return callback(err);
              }
              return MailFolder.findByMailbox(box.id, function(err, folders) {
                if (err) {
                  return callback(err);
                }
                return async.eachSeries(folders, function(folder, cb) {
                  return folder.getNewMails(getter, 200, cb);
                }, function(err) {
                  if (err) {
                    return callback(err);
                  }
                  return getter.logout(callback);
                });
              });
            });
          }
        }, function(err) {
          if (err) {
            console.log(err);
          }
          if (err) {
            return next(err);
          } else {
            return res.send({
              success: true
            });
          }
        });
      }
    });
  }
};
